import * as assert from 'assert';
import * as sinon from 'sinon';
import * as yaml from 'js-yaml';
import { OpenAPIGenerator } from '../../generators/OpenAPIGenerator';
import { ValidationService, ValidationResult } from '../../services/ValidationService';
import { RouteInfo, HttpMethod } from '../../types/RouteInfo';

/**
 * 4.3.2 Pengujian Validasi Terhadap Format OpenAPI
 *
 * These tests verify that the documents generated by OpenAPIGenerator
 * conform to the OpenAPI 3.1 specification by running them through
 * ValidationService (which uses openapi-schema-validator internally).
 */
describe('OpenAPI Format Validation Tests', () => {
    let validator: ValidationService;
    let sandbox: sinon.SinonSandbox;

    beforeEach(() => {
        sandbox = sinon.createSandbox();
        sandbox.stub(console, 'log');
        sandbox.stub(console, 'warn');
        sandbox.stub(console, 'error');
        validator = new ValidationService();
    });

    afterEach(() => {
        sandbox.restore();
    });

    // ── Helpers ─────────────────────────────────────────────────────

    function makeRoute(overrides: Partial<RouteInfo> = {}): RouteInfo {
        return {
            method: HttpMethod.GET,
            path: '/users',
            handler: 'getUsers',
            parameters: [],
            responses: [{ statusCode: 200, description: 'Success' }],
            middlewares: [],
            filePath: '/src/routes/users.js',
            ...overrides,
        };
    }

    function generateAndValidate(routes: RouteInfo[], title?: string, version?: string): ValidationResult {
        const generator = new OpenAPIGenerator(
            title || 'Test API',
            version || '1.0.0',
            'Generated for validation testing',
        );
        generator.addRoutes(routes);
        generator.finalizeDocument();
        generator.setServer('http://localhost:3000', 'Test server');

        const doc = generator.getDocument();
        return validator.validateDocument(doc);
    }

    // ── 1. Validasi Struktur Dasar OpenAPI ──────────────────────────

    describe('Basic OpenAPI Structure Validation', () => {
        it('should produce a valid document with a single GET route', () => {
            const result = generateAndValidate([makeRoute()]);

            assert.strictEqual(result.isValid, true, 'Document should be valid');
            assert.strictEqual(result.errors.length, 0, 'Should have no errors');
        });

        it('should contain openapi version 3.1.0', () => {
            const gen = new OpenAPIGenerator('My API', '1.0.0');
            const doc = gen.getDocument();

            assert.strictEqual(doc.openapi, '3.1.0');
        });

        it('should contain required info.title and info.version', () => {
            const gen = new OpenAPIGenerator('My API', '2.0.0');
            const doc = gen.getDocument();

            assert.strictEqual(doc.info.title, 'My API');
            assert.strictEqual(doc.info.version, '2.0.0');
        });

        it('should contain a valid paths object', () => {
            const gen = new OpenAPIGenerator();
            gen.addRoutes([makeRoute()]);
            const doc = gen.getDocument();

            assert.ok(doc.paths, 'paths should exist');
            assert.ok(Object.keys(doc.paths).length > 0, 'paths should not be empty');
        });

        it('should pass validation with minimal required fields', () => {
            const minimalDoc = {
                openapi: '3.1.0',
                info: { title: 'Minimal API', version: '1.0.0' },
                paths: {},
            };
            const result = validator.validateDocument(minimalDoc);

            assert.strictEqual(result.isValid, true);
        });
    });

    // ── 2. Validasi Path dan Operasi HTTP ───────────────────────────

    describe('Path and HTTP Operation Validation', () => {
        it('should validate a document with all CRUD operations on one path', () => {
            const routes: RouteInfo[] = [
                makeRoute({ method: HttpMethod.GET, path: '/users' }),
                makeRoute({ method: HttpMethod.POST, path: '/users', handler: 'createUser' }),
                makeRoute({ method: HttpMethod.PUT, path: '/users/:id', handler: 'updateUser' }),
                makeRoute({ method: HttpMethod.DELETE, path: '/users/:id', handler: 'deleteUser' }),
            ];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
            assert.strictEqual(result.errors.length, 0);
        });

        it('should convert Express path parameters to OpenAPI format', () => {
            const routes = [makeRoute({ path: '/users/:id/posts/:postId' })];
            const gen = new OpenAPIGenerator();
            gen.addRoutes(routes);

            const doc = gen.getDocument();
            const paths = Object.keys(doc.paths);

            assert.ok(
                paths.some(p => p.includes('{id}') && p.includes('{postId}')),
                'Path should use {param} syntax',
            );
        });

        it('should validate multiple independent endpoints', () => {
            const routes: RouteInfo[] = [
                makeRoute({ method: HttpMethod.GET, path: '/users', handler: 'listUsers' }),
                makeRoute({ method: HttpMethod.GET, path: '/products', handler: 'listProducts' }),
                makeRoute({ method: HttpMethod.GET, path: '/orders', handler: 'listOrders' }),
                makeRoute({ method: HttpMethod.POST, path: '/orders', handler: 'createOrder' }),
            ];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
            assert.strictEqual(result.errors.length, 0);
        });

        it('should generate a valid operationId for each operation', () => {
            const routes = [makeRoute({ handler: 'fetchUsers' })];
            const gen = new OpenAPIGenerator();
            gen.addRoutes(routes);

            const doc = gen.getDocument();
            const op = doc.paths['/users']?.get;

            assert.ok(op?.operationId, 'operationId should exist');
            assert.strictEqual(typeof op.operationId, 'string');
        });
    });

    // ── 3. Validasi Parameter ───────────────────────────────────────

    describe('Parameter Validation', () => {
        it('should validate path parameters with correct schema', () => {
            const routes = [makeRoute({
                path: '/users/:id',
                parameters: [{
                    name: 'id',
                    type: 'path',
                    required: true,
                    dataType: 'string',
                    description: 'User ID',
                }],
            })];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
            assert.strictEqual(result.errors.length, 0);
        });

        it('should validate query parameters', () => {
            const routes = [makeRoute({
                parameters: [
                    { name: 'page', type: 'query', required: false, dataType: 'number' },
                    { name: 'limit', type: 'query', required: false, dataType: 'number' },
                    { name: 'search', type: 'query', required: false, dataType: 'string' },
                ],
            })];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
        });

        it('should validate request body for POST endpoints', () => {
            const routes = [makeRoute({
                method: HttpMethod.POST,
                path: '/users',
                handler: 'createUser',
                parameters: [
                    { name: 'name', type: 'body', required: true, dataType: 'string' },
                    { name: 'email', type: 'body', required: true, dataType: 'string' },
                    { name: 'age', type: 'body', required: false, dataType: 'number' },
                ],
            })];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
        });

        it('should validate combined path, query, and body parameters', () => {
            const routes = [makeRoute({
                method: HttpMethod.PUT,
                path: '/users/:id',
                handler: 'updateUser',
                parameters: [
                    { name: 'id', type: 'path', required: true, dataType: 'string' },
                    { name: 'fields', type: 'query', required: false, dataType: 'string' },
                    { name: 'name', type: 'body', required: false, dataType: 'string' },
                    { name: 'email', type: 'body', required: false, dataType: 'string' },
                ],
            })];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
        });
    });

    // ── 4. Validasi Response ────────────────────────────────────────

    describe('Response Validation', () => {
        it('should validate operations with multiple response codes', () => {
            const routes = [makeRoute({
                responses: [
                    { statusCode: 200, description: 'User found', contentType: 'application/json' },
                    { statusCode: 404, description: 'User not found' },
                    { statusCode: 500, description: 'Internal server error' },
                ],
            })];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
        });

        it('should ensure at least a 200 response exists even if not specified', () => {
            const routes = [makeRoute({ responses: [] })];
            const gen = new OpenAPIGenerator();
            gen.addRoutes(routes);

            const doc = gen.getDocument();
            const op = doc.paths['/users']?.get;

            assert.ok(op?.responses?.['200'], 'Default 200 response should exist');
        });

        it('should validate response with JSON schema content', () => {
            const routes = [makeRoute({
                responses: [{
                    statusCode: 200,
                    description: 'User list',
                    contentType: 'application/json',
                    schema: {
                        type: 'array',
                        items: {
                            type: 'object',
                            properties: {
                                id: { type: 'string' },
                                name: { type: 'string' },
                                email: { type: 'string' },
                            },
                        },
                    },
                }],
            })];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
        });
    });

    // ── 5. Validasi Output YAML dan JSON ────────────────────────────

    describe('YAML and JSON Output Validation', () => {
        it('should produce valid YAML that can be parsed back', () => {
            const gen = new OpenAPIGenerator('YAML Test', '1.0.0');
            gen.addRoutes([makeRoute()]);
            gen.finalizeDocument();

            const yamlOutput = gen.toYAML();
            const parsed = yaml.load(yamlOutput) as any;

            assert.strictEqual(parsed.openapi, '3.1.0');
            assert.strictEqual(parsed.info.title, 'YAML Test');
        });

        it('should produce valid JSON that can be parsed back', () => {
            const gen = new OpenAPIGenerator('JSON Test', '1.0.0');
            gen.addRoutes([makeRoute()]);
            gen.finalizeDocument();

            const jsonOutput = gen.toJSON();
            const parsed = JSON.parse(jsonOutput);

            assert.strictEqual(parsed.openapi, '3.1.0');
            assert.strictEqual(parsed.info.title, 'JSON Test');
        });

        it('should produce a YAML document that passes schema validation', () => {
            const gen = new OpenAPIGenerator('Full YAML', '2.0.0');
            gen.addRoutes([
                makeRoute({ method: HttpMethod.GET, path: '/users', handler: 'listUsers' }),
                makeRoute({ method: HttpMethod.POST, path: '/users', handler: 'createUser' }),
            ]);
            gen.finalizeDocument();
            gen.setServer('http://localhost:3000');

            const yamlContent = gen.toYAML();
            const doc = yaml.load(yamlContent);
            const result = validator.validateDocument(doc);

            assert.strictEqual(result.isValid, true);
            assert.strictEqual(result.errors.length, 0);
        });

        it('should produce a JSON document that passes schema validation', () => {
            const gen = new OpenAPIGenerator('Full JSON', '2.0.0');
            gen.addRoutes([makeRoute()]);
            gen.finalizeDocument();
            gen.setServer('http://localhost:3000');

            const jsonContent = gen.toJSON();
            const doc = JSON.parse(jsonContent);
            const result = validator.validateDocument(doc);

            assert.strictEqual(result.isValid, true);
            assert.strictEqual(result.errors.length, 0);
        });

        it('should maintain YAML/JSON equivalence for the same document', () => {
            const gen = new OpenAPIGenerator('Equivalence Test', '1.0.0');
            gen.addRoutes([makeRoute()]);
            gen.finalizeDocument();

            const fromYaml = yaml.load(gen.toYAML()) as any;
            const fromJson = JSON.parse(gen.toJSON());

            assert.deepStrictEqual(fromYaml.openapi, fromJson.openapi);
            assert.deepStrictEqual(fromYaml.info, fromJson.info);
            assert.deepStrictEqual(
                Object.keys(fromYaml.paths),
                Object.keys(fromJson.paths),
            );
        });
    });

    // ── 6. Validasi Komponen dan Tags ───────────────────────────────

    describe('Components and Tags Validation', () => {
        it('should extract tags from route paths', () => {
            const routes = [
                makeRoute({ path: '/users', handler: 'getUsers' }),
                makeRoute({ path: '/products', handler: 'getProducts' }),
            ];

            const gen = new OpenAPIGenerator();
            gen.addRoutes(routes);
            gen.finalizeDocument();

            const doc = gen.getDocument();
            const tagNames = doc.tags?.map(t => t.name) || [];

            assert.ok(tagNames.includes('Users'), 'Should have Users tag');
            assert.ok(tagNames.includes('Products'), 'Should have Products tag');
        });

        it('should include a components.schemas section', () => {
            const gen = new OpenAPIGenerator();
            gen.addRoutes([makeRoute()]);
            gen.finalizeDocument();

            const doc = gen.getDocument();
            assert.ok(doc.components, 'components should exist');
            assert.ok(doc.components?.schemas !== undefined, 'schemas should exist');
        });

        it('should pass validation with server info', () => {
            const gen = new OpenAPIGenerator('Server Test', '1.0.0');
            gen.addRoutes([makeRoute()]);
            gen.finalizeDocument();
            gen.setServer('https://api.example.com', 'Production');

            const doc = gen.getDocument();
            const result = validator.validateDocument(doc);

            assert.strictEqual(result.isValid, true);
            assert.strictEqual(doc.servers![0].url, 'https://api.example.com');
        });

        it('should add a Default tag when finalizing with no routes', () => {
            const gen = new OpenAPIGenerator();
            gen.finalizeDocument();

            const doc = gen.getDocument();
            const tagNames = doc.tags?.map(t => t.name) || [];

            assert.ok(tagNames.includes('Default'));
        });
    });

    // ── 7. Validasi Dokumen Kompleks (Simulasi Real-World) ──────────

    describe('Complex Document Validation (Real-World Simulation)', () => {
        it('should validate a complete REST API with CRUD endpoints', () => {
            const routes: RouteInfo[] = [
                makeRoute({
                    method: HttpMethod.GET,
                    path: '/users',
                    handler: 'listUsers',
                    parameters: [
                        { name: 'page', type: 'query', required: false, dataType: 'number' },
                        { name: 'limit', type: 'query', required: false, dataType: 'number' },
                    ],
                    responses: [
                        { statusCode: 200, description: 'List of users', contentType: 'application/json' },
                    ],
                }),
                makeRoute({
                    method: HttpMethod.GET,
                    path: '/users/:id',
                    handler: 'getUserById',
                    parameters: [
                        { name: 'id', type: 'path', required: true, dataType: 'string' },
                    ],
                    responses: [
                        { statusCode: 200, description: 'User found' },
                        { statusCode: 404, description: 'User not found' },
                    ],
                }),
                makeRoute({
                    method: HttpMethod.POST,
                    path: '/users',
                    handler: 'createUser',
                    parameters: [
                        { name: 'name', type: 'body', required: true, dataType: 'string' },
                        { name: 'email', type: 'body', required: true, dataType: 'string' },
                    ],
                    responses: [
                        { statusCode: 201, description: 'User created' },
                        { statusCode: 400, description: 'Invalid input' },
                    ],
                }),
                makeRoute({
                    method: HttpMethod.PUT,
                    path: '/users/:id',
                    handler: 'updateUser',
                    parameters: [
                        { name: 'id', type: 'path', required: true, dataType: 'string' },
                        { name: 'name', type: 'body', required: false, dataType: 'string' },
                        { name: 'email', type: 'body', required: false, dataType: 'string' },
                    ],
                    responses: [
                        { statusCode: 200, description: 'User updated' },
                        { statusCode: 404, description: 'User not found' },
                    ],
                }),
                makeRoute({
                    method: HttpMethod.DELETE,
                    path: '/users/:id',
                    handler: 'deleteUser',
                    parameters: [
                        { name: 'id', type: 'path', required: true, dataType: 'string' },
                    ],
                    responses: [
                        { statusCode: 200, description: 'User deleted' },
                        { statusCode: 404, description: 'User not found' },
                    ],
                }),
            ];

            const result = generateAndValidate(routes, 'User Management API', '1.0.0');

            assert.strictEqual(result.isValid, true);
            assert.strictEqual(result.errors.length, 0);
        });

        it('should validate a multi-resource API', () => {
            const routes: RouteInfo[] = [
                makeRoute({ method: HttpMethod.GET, path: '/users', handler: 'getUsers' }),
                makeRoute({ method: HttpMethod.GET, path: '/products', handler: 'getProducts' }),
                makeRoute({ method: HttpMethod.GET, path: '/orders', handler: 'getOrders' }),
                makeRoute({
                    method: HttpMethod.GET,
                    path: '/users/:userId/orders',
                    handler: 'getUserOrders',
                    parameters: [
                        { name: 'userId', type: 'path', required: true, dataType: 'string' },
                    ],
                }),
                makeRoute({
                    method: HttpMethod.POST,
                    path: '/orders',
                    handler: 'createOrder',
                    parameters: [
                        { name: 'productId', type: 'body', required: true, dataType: 'string' },
                        { name: 'quantity', type: 'body', required: true, dataType: 'number' },
                    ],
                }),
            ];

            const result = generateAndValidate(routes, 'E-Commerce API', '2.0.0');

            assert.strictEqual(result.isValid, true);
            assert.strictEqual(result.errors.length, 0);
        });

        it('should validate with middleware-bearing routes', () => {
            const routes: RouteInfo[] = [
                makeRoute({
                    method: HttpMethod.GET,
                    path: '/admin/users',
                    handler: 'getAdminUsers',
                    middlewares: [
                        { name: 'authMiddleware', type: 'auth' },
                        { name: 'adminOnly', type: 'auth' },
                    ],
                }),
            ];

            const result = generateAndValidate(routes);

            assert.strictEqual(result.isValid, true);
        });
    });

    // ── 8. Deteksi Dokumen Tidak Valid ───────────────────────────────

    describe('Invalid Document Detection', () => {
        it('should detect missing info field', () => {
            const doc = { openapi: '3.1.0', paths: {} };
            const result = validator.validateDocument(doc);

            assert.strictEqual(result.isValid, false);
            assert.ok(result.errors.some(e => e.message.includes('info')));
        });

        it('should detect missing info.title', () => {
            const doc = {
                openapi: '3.1.0',
                info: { version: '1.0.0' },
                paths: {},
            };
            const result = validator.validateDocument(doc);

            assert.strictEqual(result.isValid, false);
            assert.ok(result.errors.some(e => e.message.includes('title')));
        });

        it('should detect missing info.version', () => {
            const doc = {
                openapi: '3.1.0',
                info: { title: 'Broken API' },
                paths: {},
            };
            const result = validator.validateDocument(doc);

            assert.strictEqual(result.isValid, false);
            assert.ok(result.errors.some(e => e.message.includes('version')));
        });

        it('should warn when paths is empty', () => {
            const doc = {
                openapi: '3.1.0',
                info: { title: 'Empty API', version: '1.0.0' },
                paths: {},
            };
            const result = validator.validateDocument(doc);

            assert.ok(result.warnings.some(w => w.message.includes('No paths')));
        });

        it('should detect operation without responses', () => {
            const doc = {
                openapi: '3.1.0',
                info: { title: 'No Responses', version: '1.0.0' },
                paths: {
                    '/test': {
                        get: { summary: 'Test' },
                    },
                },
            };
            const result = validator.validateDocument(doc);

            assert.ok(result.errors.some(e => e.message.includes('response')));
        });

        it('should detect parameter without name', () => {
            const doc = {
                openapi: '3.1.0',
                info: { title: 'Bad Param', version: '1.0.0' },
                paths: {
                    '/test': {
                        get: {
                            summary: 'Test',
                            parameters: [{ in: 'query', schema: { type: 'string' } }],
                            responses: { '200': { description: 'OK' } },
                        },
                    },
                },
            };
            const result = validator.validateDocument(doc);

            assert.strictEqual(result.isValid, false);
        });

        it('should detect parameter without "in" field', () => {
            const doc = {
                openapi: '3.1.0',
                info: { title: 'Bad Param', version: '1.0.0' },
                paths: {
                    '/test': {
                        get: {
                            summary: 'Test',
                            parameters: [{ name: 'q', schema: { type: 'string' } }],
                            responses: { '200': { description: 'OK' } },
                        },
                    },
                },
            };
            const result = validator.validateDocument(doc);

            assert.strictEqual(result.isValid, false);
        });
    });

    // ── 9. Validasi Report Generation ───────────────────────────────

    describe('Validation Report Generation', () => {
        it('should generate a VALID report for a correct document', () => {
            const result = generateAndValidate([makeRoute()]);
            const report = validator.generateReport(result);

            assert.ok(report.includes('VALID'));
            assert.ok(report.includes('OPENAPI VALIDATION REPORT'));
        });

        it('should generate an INVALID report with listed errors', () => {
            const doc = { openapi: '3.1.0', paths: {} };
            const result = validator.validateDocument(doc);
            const report = validator.generateReport(result);

            assert.ok(report.includes('INVALID'));
            assert.ok(report.includes('ERRORS'));
        });

        it('should include suggestions in warnings', () => {
            const doc = {
                openapi: '3.1.0',
                info: { title: 'Test', version: '1.0.0' },
                paths: {},
            };
            const result = validator.validateDocument(doc);
            const report = validator.generateReport(result);

            assert.ok(report.includes('WARNINGS') || report.includes('Suggestion'));
        });
    });
});
